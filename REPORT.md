# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Одинцов А.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение


Список в Прологе - это специальный вид терма, представляющего последовательность элементов - произвольных термов (в том числе и списков).
В Прологе, списки - это рекурсивные структуры данных, состоящие из головы (первого элемента) и хвоста (оставшихся элементов). Это позволяет легко реализовывать рекурсивные алгоритмы и обрабатывать данные рекурсивно в Прологе.

Списки в Прологе похожи на массивы или связные списки в традиционных языках программирования. Однако, в Прологе списки рекурсивно определены, что позволяет эффективно и удобно работать с ними при реализации логических программ. 

Однако Список в императивных языках сильно отличается от списка в Прологе. Обработка списка в прологе может осуществляться только рекурсивно, а в императивных языках мы можем использовать итераторы для обращения к элементам списка. В императивных языках данные обычно хранятся в массивах или списочных структурах данных, где доступ к элементам осуществляется по индексу. Список в императивном языке может содержать в себе только элементы одинакового типа, в Прологе списки содержат любые элементы.

## Задание 1.1: Предикат обработки списка

`replace(Old, New, List, Res)` - Замена всех элементов списка с указанным значением на другое значение.

Примеры использования:
```prolog
?- replace(2, 5, [1, 2, 3, 2, 4, 2], X).
X = [1, 5, 3, 5, 4, 5]
?- replace(X, Y, [1, 2, 3, 2, 4, 2], [9, 2, 3, 2, 4, 2]).
X = 1,
Y = 9
```

Реализация:
```prolog
replace(_, _, [], []). 

replace(Old, New, [Old|T], [New|T1]) :- 
    replace(Old, New, T, T1).

replace(Old, New, [H|T], [H|T1]) :- 
    H \= Old,
    replace(Old, New, T, T1).
```

Реализация на стандартных предикатах:
```prolog
replace(_, _, [], []). 

replace(Old, New, [Old|T], Y) :-  
    replace(Old, New, T, T1),    
    append([New], T1, Y).
 
replace(Old, New, [H|T], Y) :-     
    H \= Old,
    replace(Old, New, T, T1),   
    append([H], T1, Y).
```

Предикат с помощтю рекурсии идёт по списку и сравнивает голову списка со значением, которое необходимо заменить. Если голова списка совпадает с эти значением, то предикат заменяет его на новое, иначе продолжает идти по списку. Если список пуст - завершение ркурсии.

В предикате на стандартных предикатах происходит рекурсивных проход по списку, где каждый раз предикат с помощью append присоединяет в начало списке новое значение, если голова списка совпадает со значением, которое необходимо заменить, и голову списка, если не совпарают. Если список пуст - завершение ркурсии.

## Задание 1.2: Предикат обработки числового списка

`split_list(List, List1, List2)` - Разделение списка на два по порядковому принципу (первый-второй).

Примеры использования:
```prolog
?- split_list([1,2,3,4,5,6,7], List1, List2).
List1 = [1, 3, 5, 7],
List2 = [2, 4, 6]
?- split_list(List, [1,2,3], [4,5]).
List = [1, 4, 2, 5, 3]
```

Реализация:
```prolog
split_list([], [], []).
split_list([X], [X], []).
split_list([X, Y|T], [X|T1], [Y|T2]) :- 
    split_list(T, T1, T2).

```

Реализация на стандартных предикатах:
```prolog
split_list([], [], []).
split_list([X], [X], []).
split_list([X, Y|[]], [X], [Y]).
split_list([X, Y|T], L1, L2) :- 
    split_list(T, T1, T2),
    append([X], T1, L1),
    append([Y], T2, L2).
```

Предикат сопоставлет голове первого списка значение первого элемента изначального списка(или его хвоста), а голове второго значение второго элемента изначального списка(или его хвоста). И рекрсивно продолжается с оставшимся хвостом изначального списка. Когда в списе остался 1 элемент - передаёт его первому списку.

На стандартных предикатах: рекурсивно идёт по списку и присоединяет с помощью append первое значение изначального списка(или его хвоста) первому списку, а второе значение присоединяет второму списку.

Пример совместного использования предикатов.

`sharing(List, List1, List2).` - Разделение списка на два новых и обмен между ними элементами равными значениям первого в каждом списке

Примеры использования:
```prolog
?- sharing([1,2,3,4,5,6,7], List1, List2).
List1 = [2, 3, 5, 7],
List2 = [1, 4, 6]
?- sharing([1,2,1,1,1,2,2], List1, List2).
List1 = [2, 2, 2, 2],
List2 = [1, 1, 1]
```

Реализация:
```prolog
sharing(L, R1, R2) :-
    split_list(L, [H1|T1], [H2|T2]),
    replace(H1, H2, [H1|T1], R1),
    replace(H2, H1, [H2|T2], R2).

```

Предикат разделяет спискок на 2 новых и меняет между этими списками элементы равные значению элементов голов этих списков. 

## Задание 2: Реляционное представление данных

Реляционное представление данных достаточно удобно для понимания. Представление связи между данными в виде правил достаточно понятно и просто обрабатывается. Реляционная модель позволяет организовать данные в логически связанные таблицы, что упрощает их хранение и обработку. К недостаткам можно отнести то, что такое представление занимают больший объем памяти, чем нереряционное представление. Реляционные базы данных могут столкнуться с проблемами производительности при работе с большими объемами данных или сложными запросами. Реляционные базы данных обычно требуют строгого определения схемы данных, что означает, что изменение структуры таблиц может быть затруднительным и требовать значительных усилий. Далеко не всегда предметная область может быть представлена в виде таблиц. 

В файле three.pl данные представлены в виде фактов, в которых хранятся данные о группе студента, фамилии и его оценках за разные предметы. Это удобный способ представления данных - при поиске той или иной информации не придется перебирать слишком большое количество фактов, однако во время каждой итерации приходится сохранять большое количество данных, которые могут быть не нужны.

`average_mark(Student, Average)` - Средний балл студента

Примеры использования:
```prolog
?- average_mark('Петров',X).
X = 4
?- average_mark(X,4).
X = 'Петров'
X = 'Иванов'
X = 'Сидоров'
X = 'Биткоинов'
X = 'Программиро'
X = 'Круглотличников'
```

Реализация:
```prolog
average_mark(Student, Average):-
    student(_,Student,Marks),
    sum(Marks,Sum),
    length(Marks,Len),
    Average is Sum/Len.
```

Предикат определяет сумму оценок заданного студента и находит средий балл, поделив сумму на длину.

`average_mark(Student, Average)` - Сдал ли студент

Примеры использования:
```prolog
?- passed('Иванов').
true
?- passed(X).
X = 'Петров'
X = 'Иванов'
X = 'Ивановский'
X = 'Биткоинов'
X = 'Эфиркина'
X = 'Сиплюсплюсов'
X = 'Программиро'
X = 'Джаво'
X = 'Фулл'
X = 'Безумников'
X = 'Решетников'
X = 'Эксель'
X = 'Текстописова'
X = 'Густобуквенникова'
X = 'Криптовалютников'
X = 'Вебсервисов'
X = 'Круглотличников'

```

Реализация:
```prolog
passed(Student):-
    student(_,Student,Marks),
    not(member(grade(_,2),Marks)).
```
Предикат ищет в списке оценок 2, если 2 не обнаржено, то студент сдал экзамены.


`not_passed_subject(Subject,Count)` - Для каждого предмета, найти количество не сдавших студентов

Примеры использования:
```prolog
?- not_passed_subject('Математический анализ',Count)
Count = 3
?- not_passed_subject(A,B)
A = 'Логическое программирование',
B = 0
A = 'Математический анализ',
B = 3
A = 'Функциональное программирование',
B = 3
A = 'Информатика',
B = 3
A = 'Английский язык',
B = 2
A = 'Психология',
B = 3
```

Реализация:
```prolog
list([grade(Sub,2)|_],Sub).
list([_|T],Sub):-
    list(T,Sub).

not_passed_subject(Subject,Count):- 
    subject(Abb,Subject),
    findall(Marks,(student(_,_,Marks),list(Marks,Abb)),All_marks),
    length(All_marks,Count).
```

Предикат выделяет аббревиатуру предмета, составлет список двоек для этого предмета и вычисляет длинну этого списка.

`max_average_students(Group, Students)` - Для каждой группы, найти студента (студентов) с максимальным средним баллом

Примеры использования:
```prolog
?- max_average_students(101, Students)
Students = ['Безумников', 'Густобуквенникова']
?- max_average_students(Group, Students)
Students = ['Фулл', 'Безумников', 'Густобуквенникова', 'Азурин', 'Вебсервисов']
```

Реализация:
```prolog
max_average_students(Group, Students) :-
    findall(Average-Student, (student(Group, Student, _), average_mark(Student, Average)), StudentAverages),
    max_member(MaxAverage-_, StudentAverages),
    findall(Student, member(MaxAverage-Student, StudentAverages), Students).
```

Предикат в списке всех средних баллов в группе находит максимальный. Затем находит всех студентов группы с таким средним баллом.

## Выводы

В данной лабораторной работе я научился программировать в Прологе. Я понял, что основным принципом работы в Прологе является рекурсия, строящая дерево, которое испольуется для поиска решений. Было получено умение работать со списками в языке Пролог (основной прицип работы со списоком состоит в отделении головы списка и рекурсивном вызове для хвоста). Программы на языке пролог очень удобны для понимания, Пролог хорошо подходит для решения определённых задач. Однако, императивные языки программирования куда более гибкие, лёгкие в создании комплексных программ, удобные в отладке. Написание программы на Прологе заставляет использовать совершенно иной подход, чем в императивных языках.



