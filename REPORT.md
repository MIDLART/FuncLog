# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Одинцов А.М.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение


Список в Прологе - это специальный вид терма, представляющего последовательность элементов - произвольных термов (в том числе и списков).
В Прологе, списки - это рекурсивные структуры данных, состоящие из головы (первого элемента) и хвоста (оставшихся элементов). Это позволяет легко реализовывать рекурсивные алгоритмы и обрабатывать данные рекурсивно в Прологе.

Списки в Прологе похожи на массивы или связные списки в традиционных языках программирования. Однако, в Прологе списки рекурсивно определены, что позволяет эффективно и удобно работать с ними при реализации логических программ. 

Однако Список в императивных языках сильно отличается от списка в Прологе. Обработка списка в прологе может осуществляться только рекурсивно, а в императивных языках мы можем использовать итераторы для обращения к элементам списка. В императивных языках данные обычно хранятся в массивах или списочных структурах данных, где доступ к элементам осуществляется по индексу. Список в императивном языке может содержать в себе только элементы одинакового типа, в Прологе списки содержат любые элементы.

## Задание 1.1: Предикат обработки списка

`replace(Old, New, List, Res)` - Замена всех элементов списка с указанным значением на другое значение.

Примеры использования:
```prolog
?- replace(2, 5, [1, 2, 3, 2, 4, 2], X).
X = [1, 5, 3, 5, 4, 5]
?- replace(X, Y, [1, 2, 3, 2, 4, 2], [9, 2, 3, 2, 4, 2]).
X = 1,
Y = 9
```

Реализация:
```prolog
replace(_, _, [], []). 

replace(Old, New, [Old|T], [New|T1]) :- 
    replace(Old, New, T, T1).

replace(Old, New, [H|T], [H|T1]) :- 
    H \= Old,
    replace(Old, New, T, T1).
```

Реализация на стандартных предикатах:
```prolog
replace(_, _, [], []). 

replace(Old, New, [Old|T], Y) :-  
    replace(Old, New, T, T1),    
    append([New], T1, Y).
 
replace(Old, New, [H|T], Y) :-     
    H \= Old,
    replace(Old, New, T, T1),   
    append([H], T1, Y).
```

Предикат с помощтю рекурсии идёт по списку и сравнивает голову списка со значением, которое необходимо заменить. Если голова списка совпадает с эти значением, то предикат заменяет его на новое, иначе продолжает идти по списку. Если список пуст - завершение ркурсии.

В предикате на стандартных предикатах происходит рекурсивных проход по списку, где каждый раз предикат с помощью append присоединяет в начало списке новое значение, если голова списка совпадает со значением, которое необходимо заменить, и голову списка, если не совпарают. Если список пуст - завершение ркурсии.

## Задание 1.2: Предикат обработки числового списка

`split_list(List, List1, List2)` - Разделение списка на два по порядковому принципу (первый-второй).

Примеры использования:
```prolog
?- split_list([1,2,3,4,5,6,7], List1, List2).
List1 = [1, 3, 5, 7],
List2 = [2, 4, 6]
?- split_list(List, [1,2,3], [4,5]).
List = [1, 4, 2, 5, 3]
```

Реализация:
```prolog
split_list([], [], []).
split_list([X], [X], []).
split_list([X, Y|T], [X|T1], [Y|T2]) :- 
    split_list(T, T1, T2).

```

Реализация на стандартных предикатах:
```prolog
split_list([], [], []).
split_list([X], [X], []).
split_list([X, Y|[]], [X], [Y]).
split_list([X, Y|T], L1, L2) :- 
    split_list(T, T1, T2),
    append([X], T1, L1),
    append([Y], T2, L2).
```

Предикат сопоставлет голове первого списка значение первого элемента изначального списка(или его хвоста), а голове второго значение второго элемента изначального списка(или его хвоста). И рекрсивно продолжается с оставшимся хвостом изначального списка. Когда в списе остался 1 элемент - передаёт его первому списку.

На стандартных предикатах: рекурсивно идёт по списку и присоединяет с помощью append первое значение изначального списка(или его хвоста) первому списку, а второе значение присоединяет второму списку.

Пример совместного использования предикатов.

`sharing(List, List1, List2).` - Разделение списка на два новых и обмен между ними элементами равными значениям первого в каждом списке

Примеры использования:
```prolog
?- sharing([1,2,3,4,5,6,7], List1, List2).
List1 = [2, 3, 5, 7],
List2 = [1, 4, 6]
?- sharing([1,2,1,1,1,2,2], List1, List2).
List1 = [2, 2, 2, 2],
List2 = [1, 1, 1]
```

Реализация:
```prolog
sharing(L, R1, R2) :-
    split_list(L, [H1|T1], [H2|T2]),
    replace(H1, H2, [H1|T1], R1),
    replace(H2, H1, [H2|T2], R2).

```

Предикат разделяет спискок на 2 новых и меняет между этими списками элементы равные значению элементов голов этих списков. 

## Задание 2: Реляционное представление данных

Опишите, в чем преимущества и недостатки реляционного представления в целом, и конкретного представления, которое вы использовали.

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.




